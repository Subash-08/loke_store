const PDFDocument = require('pdfkit');
const fs = require('fs').promises;
const fsSync = require('fs');
const path = require('path');

class ShippingLabelGenerator {
    constructor() {
        this.fonts = {
            regular: 'Helvetica',
            bold: 'Helvetica-Bold',
        };
        this.colors = {
            dark: '#111111',
            mid: '#444444',
            light: '#888888',
            accent: '#1a1a2e',      // deep navy
            accentLight: '#2d3561', // mid navy
            white: '#ffffff',
            divider: '#dddddd',
            rowBg: '#f7f7f7',
        };

        // 4x6 inch label = 288 x 432 pt
        this.labelWidth = 288;
        this.labelHeight = 432;

        this.autoGeneratedPath = path.join(process.cwd(), 'uploads', 'labels', 'auto-generated');
        // ✅ Updated logo path
        this.logoPath = path.join(process.cwd(), 'backend', 'public', 'Loke Store Logo.png');
        this.initialized = false;
    }

    async init() {
        if (this.initialized) return;
        try {
            await fs.mkdir(this.autoGeneratedPath, { recursive: true });
            this.initialized = true;
        } catch (error) {
            console.error('❌ Failed to init shipping label generator:', error);
        }
    }

    async generateLabel(order, user) {
        if (!this.initialized) await this.init();

        const pdfBuffer = await this._createLabelPDF(order, user);
        const fileName = `LABEL-${order.orderNumber}-${Date.now()}.pdf`;
        const filePath = path.join(this.autoGeneratedPath, fileName);
        const pdfUrl = `/uploads/labels/auto-generated/${fileName}`;

        await fs.writeFile(filePath, pdfBuffer);
        return { pdfBuffer, filePath, fileName, pdfUrl, trackingId: `TRK-${order.orderNumber}` };
    }

    async _createLabelPDF(order, user) {
        return new Promise((resolve, reject) => {
            try {
                const doc = new PDFDocument({
                    margin: 0,
                    size: [this.labelWidth, this.labelHeight],
                    autoFirstPage: false,
                });
                const chunks = [];

                doc.on('data', chunk => chunks.push(chunk));
                doc.on('end', () => resolve(Buffer.concat(chunks)));
                doc.on('error', err => reject(err));

                doc.addPage({ size: [this.labelWidth, this.labelHeight], margin: 0 });
                this._generateContent(doc, order, user);
                doc.end();
            } catch (error) {
                reject(error);
            }
        });
    }

    _hr(doc, y, x1, x2, lw = 0.5, color = '#dddddd') {
        doc.moveTo(x1, y).lineTo(x2, y).lineWidth(lw).strokeColor(color).stroke();
    }

    _generateContent(doc, order, user) {
        const W = this.labelWidth;
        const PAD = 14;
        const innerW = W - PAD * 2;

        const shipping = order.shippingAddress || {};
        const toName = `${shipping.firstName || user.firstName || ''} ${shipping.lastName || user.lastName || ''}`.trim().toUpperCase();
        const toAddr1 = (shipping.addressLine1 || '').toUpperCase();
        const toCity = `${shipping.city || ''}, ${shipping.state || ''} - ${shipping.pincode || ''}`.toUpperCase();
        const toPhone = shipping.phone || shipping.mobile || (user && user.phone) || '';

        const isPrepaid = order.isPaid ? 'PREPAID' : 'COD';
        const orderNum = order.orderNumber || '';
        const orderDate = new Date(order.createdAt).toLocaleDateString('en-IN');

        // ══════════════════════════════════════════════════
        // SECTION 1: HEADER BAR (white background)
        // ══════════════════════════════════════════════════
        const HEADER_H = 48;
        // White background
        doc.rect(0, 0, W, HEADER_H).fill(this.colors.white);

        // Logo (left side)
        const logoLoaded = fsSync.existsSync(this.logoPath);
        if (logoLoaded) {
            try {
                doc.image(this.logoPath, PAD, 4, { height: 44, fit: [130, 44] });
            } catch (e) {
                // Fallback text
                doc.font(this.fonts.bold).fontSize(14).fillColor(this.colors.accent)
                    .text('LOKE STORE', PAD, 16, { lineBreak: false });
            }
        } else {
            doc.font(this.fonts.bold).fontSize(14).fillColor(this.colors.accent)
                .text('LOKE STORE', PAD, 16, { lineBreak: false });
        }

        // "SHIPPING LABEL" + PREPAID + order# — RIGHT side (wider block)
        const rightLabelW = 100;
        const rightLabelX = W - PAD - rightLabelW;
        doc.font(this.fonts.regular).fontSize(6.5).fillColor(this.colors.dark)
            .text('SHIPPING LABEL', rightLabelX, 10, { width: rightLabelW, align: 'right', lineBreak: false });
        doc.font(this.fonts.bold).fontSize(9).fillColor(this.colors.accentLight)
            .text(isPrepaid, rightLabelX, 21, { width: rightLabelW, align: 'right', lineBreak: false });
        doc.font(this.fonts.regular).fontSize(6).fillColor(this.colors.mid)
            .text(`#${orderNum}`, rightLabelX, 33, { width: rightLabelW, align: 'right', lineBreak: false });

        // Bottom border line to separate header from body
        doc.rect(0, HEADER_H - 1, W, 2).fill(this.colors.accentLight);

        let y = HEADER_H + 8;

        // ══════════════════════════════════════════════════
        // SECTION 2: TWO COLUMNS — TO (left) | FROM (right)
        // ══════════════════════════════════════════════════
        const colW = innerW / 2 - 4;
        const leftX = PAD;
        const rightX = PAD + colW + 8;

        // ── TO column ──────────────────────────────────────
        // "TO" pill label
        doc.rect(leftX, y, 22, 11).fill(this.colors.accentLight);
        doc.font(this.fonts.bold).fontSize(6.5).fillColor(this.colors.white)
            .text('TO', leftX + 4, y + 2, { lineBreak: false });

        y += 14;

        doc.font(this.fonts.bold).fontSize(10).fillColor(this.colors.dark)
            .text(toName, leftX, y, { width: colW, lineBreak: false });
        y += 13;

        doc.font(this.fonts.regular).fontSize(7.5).fillColor(this.colors.mid);
        if (toAddr1) {
            doc.text(toAddr1, leftX, y, { width: colW, lineBreak: false });
            y += 10;
        }
        doc.text(toCity, leftX, y, { width: colW, lineBreak: false });
        y += 10;
        if (toPhone) {
            doc.font(this.fonts.bold).fontSize(7.5).fillColor(this.colors.dark)
                .text(`Ph: ${toPhone}`, leftX, y, { width: colW, lineBreak: false });
            y += 10;
        }

        // ── FROM column ────────────────────────────────────
        const fromTopY = HEADER_H + 8;

        // "FROM" pill label
        doc.rect(rightX, fromTopY, 28, 11).fill('#e8e8f0');
        doc.font(this.fonts.bold).fontSize(6.5).fillColor(this.colors.accentLight)
            .text('FROM', rightX + 4, fromTopY + 2, { lineBreak: false });

        let fy = fromTopY + 14;
        doc.font(this.fonts.bold).fontSize(8).fillColor(this.colors.dark)
            .text('Loke Store', rightX, fy, { width: colW, lineBreak: false });
        fy += 11;

        const fromLines = ['Salem, TN 636004', 'Ph: 8825403712'];
        doc.font(this.fonts.regular).fontSize(6.5).fillColor(this.colors.mid);
        fromLines.forEach(line => {
            doc.text(line, rightX, fy, { width: colW, lineBreak: false });
            fy += 9;
        });

        y = Math.max(y, fy) + 8;

        // ══════════════════════════════════════════════════
        // SECTION 3: ORDER META STRIP
        // ══════════════════════════════════════════════════
        doc.rect(0, y, W, 0.8).fill(this.colors.divider);
        y += 1;
        doc.rect(0, y, W, 22).fill('#f0f0f5');

        const metaItems = [
            { label: 'ORDER', value: `#${orderNum}` },
            { label: 'DATE', value: orderDate },
        ];
        const metaColW = W / metaItems.length;
        metaItems.forEach((m, i) => {
            const mx = i * metaColW + PAD * 0.5;
            doc.font(this.fonts.regular).fontSize(5.5).fillColor(this.colors.white)
                .text(m.label, mx, y + 4, { width: metaColW - 4, lineBreak: false });
            doc.font(this.fonts.bold).fontSize(7).fillColor(this.colors.dark)
                .text(m.value, mx, y + 11, { width: metaColW - 4, lineBreak: false });
        });

        y += 22;
        doc.rect(0, y, W, 0.8).fill(this.colors.divider);
        y += 6;

        // ══════════════════════════════════════════════════
        // SECTION 4: ITEMS TABLE
        // ══════════════════════════════════════════════════
        const totalItems = (order.items || []).reduce((a, i) => a + (i.quantity || 1), 0);

        // Table title row
        doc.font(this.fonts.bold).fontSize(7).fillColor(this.colors.accentLight)
            .text('ITEMS', PAD, y, { lineBreak: false });
        doc.font(this.fonts.regular).fontSize(7).fillColor(this.colors.mid)
            .text(`${totalItems} total unit(s)`, PAD + 35, y, { lineBreak: false });
        y += 12;

        // Column header
        doc.rect(PAD, y, innerW, 13).fill(this.colors.accentLight);
        doc.font(this.fonts.bold).fontSize(7).fillColor(this.colors.white)
            .text('PRODUCT NAME', PAD + 4, y + 3, { width: innerW - 26, lineBreak: false });
        doc.text('QTY', PAD + innerW - 22, y + 3, { width: 20, align: 'center', lineBreak: false });
        y += 13;

        // Item rows
        (order.items || []).forEach((item, idx) => {
            let itemName = item.name || 'Product';
            if (item.variant && item.variant.name) itemName += ` – ${item.variant.name}`;

            const nameW = innerW - 26;
            const textH = doc.heightOfString(itemName, { width: nameW, fontSize: 7.5 });
            const rowH = Math.max(textH + 8, 15);

            // Alternating row bg
            if (idx % 2 === 0) {
                doc.rect(PAD, y, innerW, rowH).fill(this.colors.rowBg);
            } else {
                doc.rect(PAD, y, innerW, rowH).fill(this.colors.white);
            }

            doc.font(this.fonts.regular).fontSize(7.5).fillColor(this.colors.dark)
                .text(itemName, PAD + 4, y + 4, { width: nameW, lineBreak: true });
            doc.font(this.fonts.bold).fontSize(8).fillColor(this.colors.accentLight)
                .text(String(item.quantity || 1), PAD + nameW + 4, y + 4, { width: 20, align: 'center', lineBreak: false });

            y += rowH;
        });

        // ══════════════════════════════════════════════════
        // SECTION 5: FOOTER (always at bottom, no overlap)
        // ══════════════════════════════════════════════════
        const footerY = this.labelHeight - 24;

        // Ensure footer doesn't overlap items — if items ran long, just leave it
        this._hr(doc, footerY, PAD, W - PAD, 1, this.colors.accentLight);

        doc.font(this.fonts.bold).fontSize(8).fillColor(this.colors.accentLight)
            .text(`#${orderNum}`, PAD, footerY + 4, { width: innerW, align: 'center', lineBreak: false });
        doc.font(this.fonts.regular).fontSize(5.5).fillColor(this.colors.white)
            .text('Thank you for shopping with Loke Store', PAD, footerY + 14, { width: innerW, align: 'center', lineBreak: false });
    }
}

module.exports = new ShippingLabelGenerator();
